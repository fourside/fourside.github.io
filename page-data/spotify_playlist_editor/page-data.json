{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/spotify_playlist_editor",
    "result": {"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"Spotifyのプレイリストエディタを作りました","publishDate":"2022/03/10 13:30:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"Spotifyのプレイリストエディタを作りました 何を作ったか Spotifyのプレイリスト編集アプリです。 SpotifyのDiscover weeklyを聞きつつ（Spotifyがrecommendしてくれる週替りのプレイリストです）、気になった曲をお気に入りに追加して聞き直すという楽しみ方を…","html":"<h1>Spotifyのプレイリストエディタを作りました</h1>\n<h2>何を作ったか</h2>\n<p>Spotifyのプレイリスト編集アプリです。</p>\n<p>SpotifyのDiscover weeklyを聞きつつ（Spotifyがrecommendしてくれる週替りのプレイリストです）、気になった曲をお気に入りに追加して聞き直すという楽しみ方を2年間くらい続けているのですが、それが現在600曲以上になり、特別困ってはいないものの、何らかの基準で別なプレイリストに逃したいな…と思って作りました。</p>\n<!-- gif -->\n<p>で、こういうときは使ってみたいライブラリを触っていくのも楽しみのひとつで、それぞれ使ってみた感想を書き残します。</p>\n<h2>使ってみたライブラリ</h2>\n<p>ベースはNext.jsです。</p>\n<ul>\n<li>NextAuth.js</li>\n<li>vanilla-extract</li>\n<li>React DnD</li>\n<li>SWR</li>\n<li>Radix UI</li>\n<li>Storybook</li>\n<li>React Testing Library</li>\n<li>msw</li>\n</ul>\n<h3>NextAuth.js</h3>\n<ul>\n<li><a href=\"https://next-auth.js.org/\">NextAuth.js</a></li>\n<li>特定プロバイダのOAuth処理をNext.jsに簡単に導入してくれるやつ\n<ul>\n<li>プロバイダの数が充実していて、Spotifyもサポートされていた\n<ul>\n<li>正直、プロバイダがひとつくらいなら自前実装でもよいかも</li>\n<li>複数サポートしたいときにメリットを感じられる気がします</li>\n</ul>\n</li>\n<li>(vercelにjoinしてる方が作ってるので安心感はある)</li>\n</ul>\n</li>\n<li>戸惑ったところ\n<ul>\n<li>どうやってスコープを渡すのか\n<ul>\n<li>ProviderにクライアントIDなど渡す関数にAuthorization URLを生成するところがあり、そこにパラメータとして渡せる\n<ul>\n<li>今となってはドキュメントから参照されてるコードをちゃんと読めば分かったかも</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Spotify APIが要求するAccessTokenはどう取れるのか\n<ul>\n<li><a href=\"https://next-auth.js.org/getting-started/example#extensibility\">Getting Started | NextAuth.js</a>\n<ul>\n<li>access tokenは、jwtコールバックに渡されるaccountオブジェクトに、認証完了後にだけ入ってるので、それをtokenオブジェクトに詰め、それが次のsessionコールバックに渡されるのでそこでも詰め直しをする、というたらい回しをした</li>\n<li>このまどろっこしさ、これで正しいの？ という疑念はある…</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>vanilla-extract</h3>\n<ul>\n<li><a href=\"https://vanilla-extract.style/\">vanilla-extract</a></li>\n<li>ゼロランタイムのCSSライブラリで、<a href=\"https://2021.stateofcss.com/en-US/technologies/css-in-js\">The State of CSS 2021</a> で名前を見かけて試しに使ってみようかという感じ</li>\n<li>CSS ModuleのTypeScript版という感じ\n<ul>\n<li>className単位でexportすることになるので、エディタの補完候補がはちゃめちゃに多くなるのが気にならなければ…</li>\n</ul>\n</li>\n<li>jest実行時には多分設定が必要で、特に何もしなければCSSは生成されない\n<ul>\n<li>この <a href=\"https://vanilla-extract.style/documentation/styling-api/#stylevariants\">styleVariants</a> がjest実行時にundefinedになってしまい、テストケース内でrenderさせるとエラーが起きてしまう</li>\n<li>結局、回避する手段が分からず、styleVariantsをやめてしまった :cry:</li>\n</ul>\n</li>\n<li>スタイルの合成は、通常使う <code class=\"language-text\">style</code> 関数でできる\n<ul>\n<li>CSSのオブジェクトも受け取れるし、その配列も受け取れるようになっている。便利。</li>\n</ul>\n</li>\n<li>(改めてオフィシャルサイト見てみたら、ジョンレシグ先生のtweetが紹介されてる)</li>\n</ul>\n<h3>React DnD</h3>\n<ul>\n<li><a href=\"https://react-dnd.github.io/react-dnd/about\">React DnD</a></li>\n<li>ReactでDrag and Dropを簡単に扱えるやつ</li>\n<li>職場で触る機会があったし、シンプルに使えるので、これを採用した\n<ul>\n<li><a href=\"https://github.com/atlassian/react-beautiful-dnd\">react-beautiful-dnd</a> もデモがきれいだったしAtlassianが作ってるのかーと好印象だったんだけど、開発を止めてるそうなので見送った</li>\n<li>Dragが終わったイベント検知を、Dragが発生した側でハンドルできるのがよい\n<ul>\n<li>Dropイベント側で曲の追加をして、Dragイベント側で曲の削除をする</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>SWR</h3>\n<ul>\n<li><a href=\"https://swr.vercel.app/ja\">データ取得のための React Hooks ライブラリ – SWR</a></li>\n<li>fetchのresponseをReactのstateとして扱うやつ</li>\n<li>便利なんだけど、以下ちょっとだけ不満点がふたつ</li>\n<li>useSWRに与える第2引数のfetcherが、第1引数のkeyを受け取ることになっていて不便\n<ul>\n<li>キーがそのままリクエスト先のURLパスなら便利なんだけど、fetcherの中でzodでJSONのスキーマチェックなど、URLパス毎に個別の処理を入れたいので、URLパスを受け取れる共通化されたfetcherは作りにくい</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWRImmutable</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">playlists/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>playlistId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">getPlaylistTracks</span><span class=\"token punctuation\">(</span>playlistId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>useSWRがloadingを返してくれなくて不便\n<ul>\n<li>オフィシャルドキュメントでは、errorとdata(レスポンス)がundefinedなら読み取り中という扱いにしている</li>\n<li>ページングをするとき、<code class=\"language-text\">useSWR</code> ではなく <code class=\"language-text\">useSWRInfinite</code> というAPIを使うんだけど、その場合 loading をどう表現したらいいのか？という迷いがあり、結果こうなった</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> setSize <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWRInfinite</span><span class=\"token punctuation\">(</span>getKey<span class=\"token punctuation\">,</span> fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> loadingNext <span class=\"token operator\">=</span> size <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> data <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">&amp;&amp;</span> data<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> data<span class=\"token punctuation\">[</span>size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>「sizeは増えてるけど、data[size]番目のデータはまだ取得されていない」すなわち次ページのloading中ということ</li>\n<li>swrで持つ状態が増えるとそこでひとつ最適化をしないといけないはずだから、なるべくシンプルに保つためにloadingを持たない選択をしているのかなという理解をした</li>\n</ul>\n<h3>Radix UI</h3>\n<ul>\n<li><a href=\"https://www.radix-ui.com/docs/primitives/overview/introduction\">Radix UI</a></li>\n<li>まだメジャーバージョンが0なheadless componentライブラリ\n<ul>\n<li>focus管理とかキーボード操作とか、見た目以外のアクセシビリティを提供してくれるやつ</li>\n<li>GitHub Trendingでもよく見かける</li>\n</ul>\n</li>\n<li>Dialog(いわゆるモーダル)などを触ってみたけど、ちょいクセを感じた\n<ul>\n<li>Triggerというコンポーネント（こいつはDialogを開閉するボタン）を含めないと、ESCキーでDialogを閉じれなかったりする</li>\n</ul>\n</li>\n<li>Scroll AreaのスクロールバーがDOMで実装されていてこれが欲しかったんだけど、heightが固定じゃないとスクロールバーが出てくれなくて悲しかった（何故かは追ってない）</li>\n</ul>\n<h3>Storybook</h3>\n<ul>\n<li><a href=\"https://storybook.js.org/\">Storybook</a></li>\n<li>厳密には仕事で少し触ったことはあるけど、きちんと使いこなせてはいなかった</li>\n<li>なにより連れてくるnpmモジュールの多さにちょっと引き気味だったのと、連れてくるやつのせいでnpm auditが消えないがちなので、ちょっと及び腰だった</li>\n<li>使ってみるとシンプルな記述で、カタログ的にコンポーネントの見た目が確認できるのはすごくうれしい</li>\n<li>コンポーネントの機能だけ先に作ってから、storybookを用意して、コンポーネントが持つパターン毎にスタイルを当てる、という流れで作業できた\n<ul>\n<li>ローディングとかエラー状態とか動作確認しにくいコンポーネントが確認できるのはうれしい</li>\n<li>(余談ですが、仕事では一部 <a href=\"https://reactcosmos.org/\">React Cosmos</a> という軽量なやつを使っていて、これはこれでシンプルでよいです)</li>\n</ul>\n</li>\n<li>Storybookが用意しているドキュメントがしっかりしていて分かりやすいというのもよい</li>\n</ul>\n<h3>React Testing Library</h3>\n<ul>\n<li><a href=\"https://testing-library.com/docs/react-testing-library/intro/\">React Testing Library | Testing Library</a></li>\n<li>Reactのコンポーネント自体をテストしたことがあまりなく、これも及び腰だったので試してみたけど、これもよかった\n<ul>\n<li>Reactの内部ではなく、実際にユーザーが体験することに対して関心があるテストが書けるようになっている</li>\n<li>enzymeの置き換えになるというのがセールスポイントとしていたんだけど、かなり昔にちょろっと触った程度なので面倒臭さは忘れてしまった…\n<ul>\n<li>確かにセットアップは簡単だった</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>表示のテストはStorybookでやる（手作業になるけど）一方で動作の確認はReact Testing Libraryでカバーという棲み分けも分かりやすくてよい</li>\n<li>単項目のシンプルなフォームに対して書いたテストケースは20個くらい書いた\n<ul>\n<li>なるべくアサーションルーレットにならないように気をつけた結果の数なんだけど、思ったより少ないか</li>\n<li>必須項目のエラーをいつ出すかとか、ラベルをクリックしてフォーカスが移るかとか、enterでもボタンクリックでもsubmitできるかとか、挙動をテストしたい項目はそれなりにあって、これがテストで書けるのはかなり安心感を得られてよい\n<ul>\n<li>実際テストが通らず、バグが直せたのも体験よかった</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>MSW</h3>\n<ul>\n<li><a href=\"https://mswjs.io/\">MSW</a></li>\n<li>http通信をinterruptしてモックデータを返すやつ</li>\n<li>このアプリがほぼ出来上がってから使い始めたので、全エンドポイントにモックデータを用意するのがダルくて、ちゃんとやれてない\n<ul>\n<li>mswで定義してないエンドポイントに対してリクエストがあったとき、サーバコンソールにログが出てしまったり、socketが中途半端な状態になるのかエラーになったりしがちだった</li>\n<li>Intersection ObserverでInfinite loadingを実装するとき、リクエストが多数発生してSpotifyから429が返ってきてしまったことがあり、そのときモックデータが役に立ちました</li>\n</ul>\n</li>\n<li>Storybookやユニットテストで使えたら便利そう(まだ使えていない)</li>\n</ul>\n<h2>その他やったこと</h2>\n<ul>\n<li>ディレクトリの切り方は <a href=\"https://zenn.dev/yoshiko/articles/99f8047555f700\">SPA Componentの推しディレクトリ構成について語る</a> を参考にしました</li>\n<li>主に、components以下を model と ui に分けるやり方\n<ul>\n<li>最初は model と ui に分けなくても十分秩序あるように感じれたのだけど、Radix UI を使い始めてから ui のあり方だけに関心を持つコンポーネントが生まれ始め、分けるタイミングを感じた</li>\n<li>そしてtestやstorybook、cssも別ファイルで分かれるので、コンポーネントにべったりなhooksも外に出したりした</li>\n</ul>\n</li>\n</ul>\n<h2>やらなかったこと</h2>\n<ul>\n<li>hooksのテスト\n<ul>\n<li>それ用のライブラリである <a href=\"https://react-hooks-testing-library.com/\">React Hooks Testing Library</a> を見つけて、よしと思ったんだけど、<code class=\"language-text\">Your hook is defined alongside a component and is only used there</code> とあり、コンポーネント本体のテストでカバーすべきかと思い直したので</li>\n</ul>\n</li>\n</ul>\n<h2>難しかったこと</h2>\n<ul>\n<li>lighthouseを実行し、html形式のレポートをgh-pagesにデプロイする\n<ul>\n<li>Spotifyの認証画面から先がpuppeteerが不安定、だいたいいつもタイムオーバーになる</li>\n<li>そのせいでログイン試行がかさみ、Spotifyから疑わしい行動があったとしてパスワードリセットされてしまった</li>\n<li>無事htmlがデプロイされたとしても、githubのリポジトリが検出するlanguageがhtmlになってしまって若干悲しい</li>\n</ul>\n</li>\n<li>またlighthouseは型定義をきちんとした形で提供してくれておらず、definitely typedも存在しないので、どうにか誤魔化すしかなく、そこも面倒くさいポイントではあった</li>\n</ul>\n<h1>終わりに</h1>\n<p>以上です(これも余談ですが、一旦人に見せると満足してしまって開発意欲が減ってしまいますね、見せないで悶々と作って行くほうがいいのか？)</p>"}}}},"pageContext":{"slug":"spotify_playlist_editor","previous":{"body":{"body":"## やりたいこと\n\n現在運用しているサーバがsinatra + hamlで構成されており、バージョンアップに追従できておらず、普段からrubyを触らなくなってしまったのもあり、機能追加も億劫になっていました。そこでどうせなら\n\n- Node.jsでサーバサイドを書いてみて\n- テンプレートエンジンは使い慣れているReactを使う\n\nをやってみよう、の2点です。\n\n## サーバ\n\n最初は [Express](https://expressjs.com/) で書き始めたんですが、[State of JavaScript 2021/2022](https://app.stateofjs.com/survey/state-of-js/2021) で見かけた [Fastify](https://www.fastify.io/) で書き直しました。単純に知らないライブラリを触っておこう、それにパフォーマンスもよいらしいし、くらいのモチベーションです。（最終的にはコンテナに載せるのでfastifyが謳う「ロガーに何々を選びました」という惹句は決め手になりにくいなとは思いました）（が、最初からログがJSON形式なのは今っぽさを感じます）\n\n触ってみて分かったfastifyのよいところのひとつに、テストが書きやすさがあります。[Fastify - Testing](https://www.fastify.io/docs/latest/Guides/Testing/#benefits-of-using-fastifyinject) にある通り、`inject` メソッドで擬似的にHTTPリクエストを送ることができ、簡単にテストが書けます。\n\n## SSR\n\n単純にSSRしたいだけなら [ReactDOMServer – React](https://ja.reactjs.org/docs/react-dom-server.html) にあるメソッド群を使えばよいだけでした。`renderToStaticMarkup` は、渡したコンポーネントのレンダリング結果をHTML文字列として返してくれるメソッドです。\n\nただ今回返したいレスポンスは、HTMLではなくXMLでした。JSXの型として扱えるのは、@types/reactに定義されてある通りで、HTML要素に存在するものに限られています。当然、xml名前空間で指定されたDTDのことなんてTypeScriptは知らないので、以下のコードをXMLを扱うコンポーネントと同じモジュールに貼り付けて回避しました。\n\n```typescript\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      [elemName: string]: unknown;\n    }\n  }\n}\n```\n\nこれでもなお、`pubDate` のようなキャメルケースの要素を扱うと、レンダリング時にreact-domが次のようなwarningを出力します。\n\n```\nWarning: <pubDate /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\n```\n\nこれを抑止するには `NODE_ENV=production` を指定して実行すればよさそうです。productionではないテスト実行時などにこのwarningが出力されて鬱陶しいですが、大きな問題にはならないので一旦目をつむることにします。\n\n## hydration\n\nせっかくSSRにしたので、特にユースケースはないけどhydrationも試してみました。単語自体はSSRの文脈で目にするけれども、実際に何が起きているか、どう実装するかというのは全く知らなかったので触れてみるか、というモチベーションです。\n\n具体的には、[ReactDOMのhydrateメソッド](https://ja.reactjs.org/docs/react-dom.html#hydrate) を使います。クライアント用JSファイルのエントリポイントにて、いつもの `ReactDOM.render(<App />, document.getElementById('root'));` ではなく、`ReactDOM.hydrate(<App />, document.getElementById('root'));` とします 。renderと全く同じインターフェイスなので分かりやすいですね。hydrateメソッドによって、クライアント側では改めてDOM構築をせずに、イベントハンドラなどのアタッチ処理が行われるようです。\n\nここでAppコンポーネントが何かしらのデータを受け取るインターフェイスになっていたら、クライアント側ではどこからデータを取得すればよいかが悩みポイントでした。例えば何らかのAPIレスポンスをサーバ側では自由に取得できたとして、クライアント側で同様に取得できるか分からないし、できたとしてサーバ・クライアントで二重に取得するのは無駄で無意味です。そこでNext.jsではどうやってるのか調べてみると、SSRしたHTMLの中にJSONデータをシリアライズしたものを埋め込んでいるようでした。つまりクライアント側でそれを取得してJSON.parseできればよいわけですね。愚直な感じはしますが、workはします。\n\nここまできたらcss in jsも試してみたいと思って試行錯誤したんですが、SSRするのにビルドが必要そうだったりして簡単にできるのはここまでということにして、ひとまず終わりにします。\n\n## まとめ\n\n- 普段Next.jsなどで気にせず行われているSSRやhydrateは、身近なAPIでできる（その先がムズい）\n- Next.js触りたての頃、windowオブジェクトを評価してビルドがコケることがちょいちょいあったけど、そうなる理由がよくわかりました"},"title":"Server Side Renderingしてみました","slug":"simple_server_side_rendering","updatedAt":"2022-02-14T13:55:46.605Z"},"next":null}},
    "staticQueryHashes": ["1784162573","882115108"]}
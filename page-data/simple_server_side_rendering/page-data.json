{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/simple_server_side_rendering",
    "result": {"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"Server Side Renderingしてみました","publishDate":"2022/02/14 13:30:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"やりたいこと 現在運用しているサーバがsinatra + hamlで構成されており、バージョンアップに追従できておらず、普段からrubyを触らなくなってしまったのもあり、機能追加も億劫になっていました。そこでどうせなら Node.jsでサーバサイドを書いてみて テンプレートエンジンは使い慣れているReact…","html":"<h2>やりたいこと</h2>\n<p>現在運用しているサーバがsinatra + hamlで構成されており、バージョンアップに追従できておらず、普段からrubyを触らなくなってしまったのもあり、機能追加も億劫になっていました。そこでどうせなら</p>\n<ul>\n<li>Node.jsでサーバサイドを書いてみて</li>\n<li>テンプレートエンジンは使い慣れているReactを使う</li>\n</ul>\n<p>をやってみよう、の2点です。</p>\n<h2>サーバ</h2>\n<p>最初は <a href=\"https://expressjs.com/\">Express</a> で書き始めたんですが、<a href=\"https://app.stateofjs.com/survey/state-of-js/2021\">State of JavaScript 2021/2022</a> で見かけた <a href=\"https://www.fastify.io/\">Fastify</a> で書き直しました。単純に知らないライブラリを触っておこう、それにパフォーマンスもよいらしいし、くらいのモチベーションです。（最終的にはコンテナに載せるのでfastifyが謳う「ロガーに何々を選びました」という惹句は決め手になりにくいなとは思いました）（が、最初からログがJSON形式なのは今っぽさを感じます）</p>\n<p>触ってみて分かったfastifyのよいところのひとつに、テストが書きやすさがあります。<a href=\"https://www.fastify.io/docs/latest/Guides/Testing/#benefits-of-using-fastifyinject\">Fastify - Testing</a> にある通り、<code class=\"language-text\">inject</code> メソッドで擬似的にHTTPリクエストを送ることができ、簡単にテストが書けます。</p>\n<h2>SSR</h2>\n<p>単純にSSRしたいだけなら <a href=\"https://ja.reactjs.org/docs/react-dom-server.html\">ReactDOMServer – React</a> にあるメソッド群を使えばよいだけでした。<code class=\"language-text\">renderToStaticMarkup</code> は、渡したコンポーネントのレンダリング結果をHTML文字列として返してくれるメソッドです。</p>\n<p>ただ今回返したいレスポンスは、HTMLではなくXMLでした。JSXの型として扱えるのは、@types/reactに定義されてある通りで、HTML要素に存在するものに限られています。当然、xml名前空間で指定されたDTDのことなんてTypeScriptは知らないので、以下のコードをXMLを扱うコンポーネントと同じモジュールに貼り付けて回避しました。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">declare</span> global <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">namespace</span> <span class=\"token constant\">JSX</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">interface</span> <span class=\"token class-name\">IntrinsicElements</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">[</span>elemName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>これでもなお、<code class=\"language-text\">pubDate</code> のようなキャメルケースの要素を扱うと、レンダリング時にreact-domが次のようなwarningを出力します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Warning: &lt;pubDate /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.</code></pre></div>\n<p>これを抑止するには <code class=\"language-text\">NODE_ENV=production</code> を指定して実行すればよさそうです。productionではないテスト実行時などにこのwarningが出力されて鬱陶しいですが、大きな問題にはならないので一旦目をつむることにします。</p>\n<h2>hydration</h2>\n<p>せっかくSSRにしたので、特にユースケースはないけどhydrationも試してみました。単語自体はSSRの文脈で目にするけれども、実際に何が起きているか、どう実装するかというのは全く知らなかったので触れてみるか、というモチベーションです。</p>\n<p>具体的には、<a href=\"https://ja.reactjs.org/docs/react-dom.html#hydrate\">ReactDOMのhydrateメソッド</a> を使います。クライアント用JSファイルのエントリポイントにて、いつもの <code class=\"language-text\">ReactDOM.render(&lt;App />, document.getElementById('root'));</code> ではなく、<code class=\"language-text\">ReactDOM.hydrate(&lt;App />, document.getElementById('root'));</code> とします 。renderと全く同じインターフェイスなので分かりやすいですね。hydrateメソッドによって、クライアント側では改めてDOM構築をせずに、イベントハンドラなどのアタッチ処理が行われるようです。</p>\n<p>ここでAppコンポーネントが何かしらのデータを受け取るインターフェイスになっていたら、クライアント側ではどこからデータを取得すればよいかが悩みポイントでした。例えば何らかのAPIレスポンスをサーバ側では自由に取得できたとして、クライアント側で同様に取得できるか分からないし、できたとしてサーバ・クライアントで二重に取得するのは無駄で無意味です。そこでNext.jsではどうやってるのか調べてみると、SSRしたHTMLの中にJSONデータをシリアライズしたものを埋め込んでいるようでした。つまりクライアント側でそれを取得してJSON.parseできればよいわけですね。愚直な感じはしますが、workはします。</p>\n<p>ここまできたらcss in jsも試してみたいと思って試行錯誤したんですが、SSRするのにビルドが必要そうだったりして簡単にできるのはここまでということにして、ひとまず終わりにします。</p>\n<h2>まとめ</h2>\n<ul>\n<li>普段Next.jsなどで気にせず行われているSSRやhydrateは、身近なAPIでできる（その先がムズい）</li>\n<li>Next.js触りたての頃、windowオブジェクトを評価してビルドがコケることがちょいちょいあったけど、そうなる理由がよくわかりました</li>\n</ul>"}}}},"pageContext":{"slug":"simple_server_side_rendering","previous":{"body":{"body":"日頃から [ghコマンド](https://github.com/cli/cli \"cli/cli: GitHub’s official command line tool\") にお世話になっていまして、PR作ったり、ターミナルからリポジトリをブラウザで開くのに使ったりしているのですが、不意にバナーが出ることで新バージョンがリリースされたことを知ります。そうするとGitHubのcli/cliリポジトリのReleaseページに行き、該当するバイナリを目で選んでダウンロードし、パスに通す。という手間をやっていたのですが、流石に手作業が多すぎると思い、簡単なスクリプトを書きました。\n\n`gist:fourside/ef69da72c47779591ee9ab23af096ea4`\n\n今までちゃんと調べないで使ってたせいで、知らないオプションがいろいろありました。\n\n- `-R` オプションでカレントディレクトリ以外のリポジトリが参照できる\n- JSONのフォーマットで出力できて、さらにjqのような絞り込みができる\n\nupdateサブコマンドの実装案とかissueにないか探してたら、オフィシャルの案内ではパッケージマネージャ経由でバージョンをあげろということみたいですね…。"},"title":"ghコマンドをupdateしたい","slug":"upgrade_gh","updatedAt":"2022-01-26T14:20:23.944Z"},"next":null}},
    "staticQueryHashes": ["1784162573","882115108"]}
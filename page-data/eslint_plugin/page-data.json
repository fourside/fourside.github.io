{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/eslint_plugin",
    "result": {"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"Eslint Pluginを作りました","publishDate":"2022/03/28 13:15:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"問題 下記のようなディレクトリ構成のプロジェクトがあったとします。 このプロジェクトでは、例えば  は  からのみ依存されているとします。JavaScript…","html":"<h2>問題</h2>\n<p>下記のようなディレクトリ構成のプロジェクトがあったとします。</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">src/components/\n  model/\n    user/\n      user.tsx\n      user.css.ts\n      user.test.tsx\n      user.stories.tsx\n  page/\n    dashboard/\n      dashboard.tsx\n      dashboard.css.ts\n      dashboard.test.tsx\n      dashboard.stories.tsx\n  ui/\n    button/\n      button.tsx\n      button.css.ts\n      button.test.tsx\n      button.stories.tsx</code></pre></div>\n<p>このプロジェクトでは、例えば <code class=\"language-text\">user.css.ts</code> は <code class=\"language-text\">user.tsx</code> からのみ依存されているとします。JavaScriptには当然ディレクトリ単位での可視性のスコープなんてものはないため、<code class=\"language-text\">user.css.ts</code> は <code class=\"language-text\">dashboard.tsx</code> からも参照できてしまい、他のコンポーネントを参照する場合はエディタの補完候補に目を凝らさないといけません。</p>\n<h2>どうするか</h2>\n<p><a href=\"https://www.npmjs.com/package/eslint-plugin-import-only-from-index\">eslint-plugin-import-only-from-index</a> を作りました。</p>\n<p>eslintrcにはこのように指定します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"plugin\": [\"import-only-from-index\"],\n\"rules\": {\n  \"import-only-from-index/import-only-from-index\": [\"error\", [\"src/components\"]]\n}</code></pre></div>\n<p>オプションで指定するディレクトリ（上記例では <code class=\"language-text\">src/components</code>）からexportしたものはlint errorとします。ただし、indexファイルからexportしたものはerrorとしません。つまり指定ディレクトリから外部に公開したいものは、indexファイルからre-exportすることを強制します。</p>\n<p>これは完全な個人用途なのでpublishしなくてもいいかと思ったんですが、自分で使うときにnpm installできるのは便利だし、特に誰も困らないだろうからいいだろうと決めてpublishしました。</p>\n<h2>やったこと</h2>\n<ul>\n<li>Eslint Pluginの作成</li>\n<li>TypeScript Server Pluginの作成</li>\n</ul>\n<h3>Eslint Plugin</h3>\n<p><a href=\"https://eslint.org/docs/developer-guide/working-with-plugins\">Working with Plugins - ESLint</a> では Yeoman のテンプレートが内されていますが、npx一発では作れないので諦めました。がそれ以外は、plugin作成用のlint ruleの案内があったりしてよかったです。</p>\n<p>初手としては、<a href=\"https://github.com/Quramy/eslint-plugin-tutorial\">Quramy/eslint-plugin-tutorial</a> というチュートリアルが分かりやすかったです。pluginが求めるインターフェイス、簡単なルールの書き方、そのテストのやり方、ASTについて分かりやすく案内されています。</p>\n<p>そしてここから先はロジックの話ですが、作ってみて気づいたのが、import文の曖昧なパターンの存在です。<code class=\"language-text\">import * from './hoge';</code> としたとき、二つの解釈が生まれます。</p>\n<ul>\n<li><code class=\"language-text\">hoge</code> ディレクトリにある <code class=\"language-text\">index.ts</code> からのインポート</li>\n<li><code class=\"language-text\">hoge</code> ファイルで、何らかの拡張子が省略されている（<code class=\"language-text\">hoge.ts</code> なのか、<code class=\"language-text\">hoge.tsx</code> なのかは字句のみでは分からない）</li>\n</ul>\n<p>それらしい方法も思いつかないので、愚直にファイルシステムにアクセスして何が存在するのか確かめることにしています。それに伴って、テストでもbeforeAll/afterAllでディレクトリやファイルを作って後始末をしたくなるんですが、eslintのtest runnerにはそれがありません。そこで <a href=\"https://vitest.dev/\">Vitest</a>でeslint test runnerを囲うことにしました。Vitestは依存ライブラリが少ないし簡単に実行できてよいですね。簡単なテストにはmochaを選びがちだったんですが、これからはVitestでよさそうです。</p>\n<h3>TypeScript Server Plugin</h3>\n<p>Eslintのpluginだけではエディタの補完候補までは制御できないので、Language Serverのレスポンスに介入できるTypeScript Server Pluginを作ってみました。コンパイラオプションの <code class=\"language-text\">plugins</code> に指定します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"compilerOptions\": {\n  \"plugins\": [\n    {\n      \"name\": \"eslint-plugin-import-only-from-index\",\n      \"restrictedPath\": \"src/components\"\n    }\n  ]\n}</code></pre></div>\n<p><a href=\"https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\">Writing a Language Service Plugin · microsoft/TypeScript Wiki</a> が入門にちょうどよかったです。テストに関しては実際にプロジェクトを作って確かめろというスタンスで、どうにかテストできないかなと模索したんですが、そもそもtsserverの型定義がなく諦めました。（<a href=\"https://github.com/Quramy/typescript-eslint-language-service/blob/master/e2e/helper/server.ts\">Quramy/typescript-eslint-language-service</a> を見ると丁寧にやってて、ここまでやる気力はわかなかった…）\nユニットテストできない、かつプリントデバッグできないので、環境変数<code class=\"language-text\">TSS_LOG</code>を使って動作確認していくのがしんどかったです。多少苦労してもtsserverを扱ったほうがよいのかも。</p>\n<p>ハマりどころとして、VS Codeで使用するTypeScriptをworkspaceのものを指定しなければ動作しないというのがありました。<code class=\"language-text\">.vscode/settings.json</code>に<code class=\"language-text\"> \"typescript.tsdk\": \"node_modules/typescript/lib\"</code>と書くやつですね（F1キーで<code class=\"language-text\">TypeScript: Select TypeScript Version</code>する）。</p>\n<h3>参考にさせてもらったリポジトリや記事</h3>\n<ul>\n<li><a href=\"https://github.com/uhyo/eslint-plugin-import-access\">uhyo/eslint-plugin-import-access</a>\n<ul>\n<li>eslint pluginとtypescript server pluginを同じエントリポイントで公開する方法が参考になりました</li>\n</ul>\n</li>\n<li><a href=\"https://qiita.com/Quramy/items/c2835bc380c3e822d479#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%9B%B8%E5%BC%8F\">TSServerの使い方メモ - Qiita</a></li>\n</ul>\n<h2>おわりに</h2>\n<p>今回は単純なimport文だったのでASTの深いところまで潜らずに済みましたが、もうちょっと勉強できるお題があったらよかった…。</p>"}}}},"pageContext":{"slug":"eslint_plugin","previous":{"body":{"body":"## TL;DR\nNext.jsのドキュメントをちゃんと読んで設定を書くこと。`next/jest` は swc でビルドできるプロジェクト向け\n\n## 構成\n- Next.js 12.1\n- jest\n- React Testing Library\n- vanilla-extract\n\n## 起きたこと\nvanilla-extract の [styleVariants](https://vanilla-extract.style/documentation/styling-api/#stylevariants) を使ったコンポーネントのテストが、以下のようなエラーを吐いて失敗する。\n\n```\nTypeError: Cannot read properties of undefined (reading 'primary')\n```\n\n## 調べたこと\n- React Testing Library の `screen.debug` 関数を呼び出してみると、vanilla-extract が出力するはずのクラス名が undefined になっている\n- console.log を仕込んだ結果、どうやら jest から `@vanilla-extract/babel-plugin` が呼ばれていない\n  - こいつは `*.css.ts` ファイルを読み込んでクラス名を生成したりする babel plugin\n- `jest --verbose` で jest の実行時の設定を確認してみる\n  -  `jest --verbose hoge` のように存在しないテストケース名を与えるとテストが実施されずに早い\n- ただの好奇心から Next.js 12.1 から導入された [next/jest](https://nextjs.org/docs/testing#setting-up-jest-with-the-rust-compiler) を使っていたので、いろいろ設定が追加されている\n- transform にも予め設定があり、自分で用意した transform の設定がその後に追加されていた\n  - それもそのはず、jest.config.js では最後に `next/jest` から生成した関数で設定をwrapしてるのでそうなる\n- おそらく同一ファイルに transform は二重にかからず、自分の設定が無視されていて、結果 vanilla-extract の babel plugin が呼ばれない雰囲気が漂う\n  - 改めて調べると [Jestの設定 - transform](https://jestjs.io/ja/docs/next/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object) に `A transformer is only run once per file unless the file has changed. ` とある\n- そこで試しに `next/jest` をやめたら、あっさりスタイルは生成されるようになった\n- さらに Next.js のドキュメントをよく読むと、 [Setting up Jest (with Babel)](https://nextjs.org/docs/testing#setting-up-jest-with-babel) があり、`next/jest` を使わないならマニュアルで設定を書けとある。ドキュメントをちゃんと読もう！\n\n> If you opt-out of the Rust Compiler, you will need to manually configure Jest and install babel-jest and identity-obj-proxy in addition to the packages above.\n\nとあるものの、`babel-jest` は jest インストール時に同梱されてくるので、改めてインストールする必要はなさそう。\n\n最終的な `jest.config.js` はこれで十分でした。\n\n```js\n/** @type {import('@jest/types').Config.InitialOptions} */\nconst customJestConfig = {\n  setupFilesAfterEnv: [\"<rootDir>/jest.setup.js\"],\n  transform: {\n    \"\\\\.js$\": \"babel-jest\",\n    \"\\\\.tsx?$\": [\"babel-jest\", { configFile: \"./.babelrc\" }],\n  },\n  testEnvironment: \"jest-environment-jsdom\",\n};\n\nmodule.exports = customJestConfig;\n```\n\n（js に対する transform 設定は、単に babel.setup.js で import 文を書き直したくなかっただけのためのもの）\n\n## おわりに\nビジュアルレグレッションテストをするわけではない場合には、本来スタイル生成はテストに不要なはずなので、テストを速くするにはテスト実行時に影響する `styleVariants` API を避けないといけないのか…という悩みがうまれました。\n"},"title":"Next.js 12.1 x jest x vanilla-extract でハマったこと","slug":"next12_jest_vanilla-extract","updatedAt":"2022-03-15T01:30:22.894Z"},"next":{"body":{"body":"最近書いたコンポーネントのテストで、よかったこと気づいたことをメモしておきます。主に react testing library を使っていて、\n\n### testing library 用の eslint rule が便利\n- [eslint-plugin-testing-library | Testing Library](https://testing-library.com/docs/ecosystem-eslint-plugin-testing-library/)\n  - 「ここではgetByXXXを使うな」とか、要素取得メソッドの矯正をしてくれる\n  - `screen.debug()` もエラーにしてくれるので、消し忘れ防止になる\n  - ただ `targetElement.firstChild` みたいに直接 DOM 取得すると怒られるのは少し不便（その行だけ無効にしてしまってる）\n\n### prop drilling したコールバックのテストがしんどい\n- イベントを発火させて、コンポーネントに渡したコールバックが呼ばれていることを確認するテストを書きたい\n- イベントを発火するコンポーネントとテスト対象のコンポーネントが分かれているとき、さらにその二者が遠く離れているとき、イベント発火コンポーネントに至るまでの DOM 構造を知っていなければいけない問題がある\n  - 直接の親子なら親は子に依存してるので、少しくらい知っていてもいいかと思うのだけど、孫やひ孫くらい離れていると知りすぎている感があってつらい\n- コンポーネント毎にユニークなtest-idがあればいいのかもしれない\n  - それでも DOM 上での登場順に気を配らなくてはいけないけども\n\n### SWR を使うときはキャッシュに気をつける\n- どう考えてもテスト同士が干渉してる事象があった\n  - テストAで削除のテストをやると、テストBでは削除されたあとの状態になっていた\n- [Cache – SWR](https://swr.vercel.app/ja/docs/advanced/cache#%E3%83%86%E3%82%B9%E3%83%88%E3%82%B1%E3%83%BC%E3%82%B9%E9%96%93%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E3%83%AA%E3%82%BB%E3%83%83%E3%83%88)\n- 回避策はここに書いてあった（読んでたはずだけど、テスト間でキャッシュするなんて思い至らなかった）\n\n### @mswjs/data が便利\n- [mswjs/data](https://github.com/mswjs/data)\n- [mswjs/data で広がるテスト戦略](https://zenn.dev/takepepe/articles/msw-data-userflow-testing) で知りました\n- msw 単体で使うと取得系のテストは簡単に書けるようになるが、更新系のテストでは工夫が必要で悩んでいた\n- mswjs/data はその辺の面倒臭さをカバーしてくれるのでありがたい\n\n### React DnD テストしやすい\n- [React DnD](https://react-dnd.github.io/react-dnd/docs/testing) にテストに関する章があるくらいドキュメントがきちんとしている\n  - ただ [test backend](https://react-dnd.github.io/react-dnd/docs/backends/test) を使うのだと勘違いしていて、しばらくハマってしまった\n    - testing-library は DOM を扱うので、通常使う HTML5 backend でよい\n- userEventにdragイベントやdropイベントは実装されてないので、fireEventで扱うしかなかった\n  - [Simulate drag and drop · Issue #440 · testing-library/user-event](https://github.com/testing-library/user-event/issues/440)\n    - 実装する予定もなさそう\n\n### Intersection Observer は jsdom 環境でテストできない\n- [Support for Intersection Observer? · Issue #2032 · jsdom/jsdom](https://github.com/jsdom/jsdom/issues/2032)\n  - jsdom で Intersection Observer が実装されていなかった\n  - ひとまず下記のようなコードで参照エラーになるのを回避して、実際にテストするのは e2e でやるしかないか？ と思ってます\n\n```js\nconst intersectionObserverMock = () => ({\n  observe: () => null,\n  disconnect: () => undefined,\n});\nwindow.IntersectionObserver = jest.fn().mockImplementation(intersectionObserverMock);\n```\n\n- issueを辿っていくとshopifyがmockを実装していた\n  - [quilt/intersection-observer.ts at main · Shopify/quilt](https://github.com/Shopify/quilt/blob/main/packages/jest-dom-mocks/src/intersection-observer.ts)\n\n## 以上です\n"},"title":"コンポーネントのテストを書きました","slug":"component_tests","updatedAt":"2022-04-15T00:55:53.220Z"}}},
    "staticQueryHashes": ["1784162573","882115108"]}
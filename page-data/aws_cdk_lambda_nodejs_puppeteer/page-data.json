{"componentChunkName":"component---src-templates-blog-post-js","path":"/aws_cdk_lambda_nodejs_puppeteer","result":{"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"aws-cdk の aws-lambda-nodejs で puppeteer を動かす","publishDate":"2020/09/07 04:30:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"作ったものはこれ fourside/meigaza 映画の情報をスクレイプして、 Slack や IFTTT 経由 でモバイル通知する Lambda Function aws-cdk で Lambda とその周辺の リソースを定義した aws-cdk AWS…","html":"<ul>\n<li>\n<p>作ったものはこれ</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/fourside/meigaza\">fourside/meigaza</a></p>\n<ul>\n<li>映画の情報をスクレイプして、 Slack や IFTTT 経由 でモバイル通知する Lambda Function</li>\n</ul>\n</li>\n<li>aws-cdk で Lambda とその周辺の リソースを定義した</li>\n</ul>\n</li>\n</ul>\n<h3>aws-cdk</h3>\n<ul>\n<li>AWSのリソースをコードで表現できるフレームワーク</li>\n<li>\n<p>TypeScript で書ける</p>\n<ul>\n<li>コード補完が効いてうれしい</li>\n<li>パーミッションなどデフォで設定されるので細々定義しなくてよい</li>\n<li>CloudFormation で yaml 書くのはつらかった…</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/cdk/latest/guide/home.html\">What is the AWS CDK? - AWS Cloud Development Kit (AWS CDK)</a></p>\n<ul>\n<li><code class=\"language-text\">Getting started</code> とか読んだ</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/cdk/api/latest/docs/aws-lambda-nodejs-readme.html\">aws-lambda-nodejs module</a> が便利</p>\n<ul>\n<li>まだ experimental な状態で、さらに semver を採用してない</li>\n<li>Lambda のソースコードが TypeScript で書ける</li>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/cdk/api/latest/docs/aws-lambda-readme.html\">aws-lambda module</a> だと、CDK 部分は ts、Lambda 本体は common js になって、eslint しにくかったりコンテキストスイッチが発生したりで体験がよくない（eslint はディレクトリ毎に設定ファイルを置いても vs code が認識してくれなかった）</p>\n<ul>\n<li>なので experimental でも使う…</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>puppeteer を動かす</h3>\n<ul>\n<li><a href=\"https://github.com/alixaxel/chrome-aws-lambda\">chrome-aws-lambda</a> を <a href=\"https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-lambda.LayerVersion.html\">Lambda Layer</a> に含める</li>\n<li>\n<p>cdk deploy 時に layer のアセットを作るには以下を参照した</p>\n<ul>\n<li><a href=\"https://dev.classmethod.jp/articles/aws-cdk-node-modules-lambda-layer/\">AWS CDK を使って node_modules を AWS Lambda Layers にデプロイするサンプル | Developers.IO</a></li>\n<li>簡単にいうと、 <code class=\"language-text\">bin/{appName}.ts</code> がスタックを作る前に Layer のアセットとなる資材を作っておく</li>\n</ul>\n</li>\n<li><code class=\"language-text\">cdk deploy</code>, <code class=\"language-text\">cdk synth</code> の度に Layer の zip を作るのもコストが大きいので、もとになる package-lock.json のハッシュ値を比較して作る作らないを制御するようにした</li>\n</ul>\n<h3>aws-lambda-nodejs でローカルでビルドするときのコツ</h3>\n<ul>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/cdk/api/latest/docs/aws-lambda-nodejs-readme.html#local-bundling\">aws-lambda-nodejs - Local bundling</a></p>\n<ul>\n<li>\n<p>parcel を install してると、バンドル時にそれを使ってくれる</p>\n<ul>\n<li>ただし <a href=\"https://github.com/aws/aws-cdk/blob/v1.62.0/packages/%40aws-cdk/aws-lambda-nodejs/lib/bundlers.ts#L31\">Windows だと無視されるので </a> WSL を使う</li>\n</ul>\n</li>\n<li>そうでなければ Docker が使われる</li>\n</ul>\n</li>\n<li>Lambda を複数定義するときは、parcelのキャッシュディレクトリは分ける</li>\n<li>\n<p>Layerに含める npm モジュールをバンドルしないようにする</p>\n<ul>\n<li><code class=\"language-text\">externalModules</code> オプションに指定した npm は、<a href=\"https://github.com/parcel-bundler/parcel#targets\">parcel の targets</a> の <code class=\"language-text\">includeNodeModules</code> オプションに追加される</li>\n</ul>\n</li>\n</ul>\n<h3>misc</h3>\n<ul>\n<li>\n<p>cdk synth, cdk deploy 中は、package.json が汚れる</p>\n<ul>\n<li>Ctrl-Cなどで中断すると残ってしまう</li>\n<li>\n<p>具体的には parcel のビルドターゲット</p>\n<ul>\n<li><code class=\"language-text\">includeNodeModules</code> には <code class=\"language-text\">{npmName}: false</code> という形で設定される</li>\n<li>\n<p>parcelのドキュメントに記載されてない形なので、正しく動かないのではと思ってしまったけど、そんなことはなかった</p>\n<ul>\n<li><a href=\"https://github.com/parcel-bundler/parcel/pull/4072/files#diff-55ff0e36af2108f79d8af002e7dc6841\">Pull Request #4072 - parcel-bundler/parcel</a></li>\n</ul>\n</li>\n<li>現状、<code class=\"language-text\">externalModules</code> と <code class=\"language-text\">nodeModules</code> どちらに指定しても<a href=\"https://github.com/aws/aws-cdk/blob/v1.62.0/packages/%40aws-cdk/aws-lambda-nodejs/lib/bundling.ts#L131\">結果は同じ</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>WSLでWindows側のディレクトリを使ってビルドすると遅い</p>\n<ul>\n<li>WSL側のファイルシステムを使う</li>\n<li>vs code は wsl extension を使う</li>\n</ul>\n</li>\n</ul>"}}}},"pageContext":{"slug":"aws_cdk_lambda_nodejs_puppeteer","previous":{"body":{"body":"\nfourside.github.io を jekyll で構築していたけど、gatsby に鞍替えした。モチベーションは gatsby を触ってみたかったというくらい。\n\n### やったこと\n\nなるべくシンプルにしたかったので、オフィシャルのスターターである [gatsbyjs/gatsby-starter-blog](https://github.com/gatsbyjs/gatsby-starter-blog) を使った。とはいえSEOとかオフライン対応とかもろもろ入っているので便利。\n\n自分でカスタマイズしたのはこれくらい。移行元となるべく機能差異ないようにした（そんな機能もりもりじゃないけども…）。基本的にプラグインを入れて設定をするだけ。\n\n- 自分のアイコンは Gravatar からひっぱってきた\n- Gist を展開するようにした\n- RSS feedを吐くようにした\n- 自動でデプロイされるようにした\n\n自動デプロイについて。Contentful で publish したら走るようにした。 jekyllだと mdファイルをpushしたらGitHub Pagesが自動でビルドしてくれるが、Gatsby + Headless CMS だと、ビルド時に CMS から記事を取得しなくてはならない。具体的には Contentful Webhook と GitHub Actions の組み合わせ。Contentful で記事を操作したら GitHub API にリクエストが飛ぶようにする([Webhooks | Contentful](https://www.contentful.com/developers/docs/concepts/webhooks/))。GitHub Action で、そのリクエストが飛んできたらビルドとデプロイが走るようにする。\n\n~~デプロイは、[gh-pages](https://www.npmjs.com/package/gh-pages) を使うだけ。GitHub Pagesのブランチを `gh-pages` にしておいて、ビルド成果物だけを push する。~~ GitHub Actions では [peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-first-deployment-with-github_token) を使うようにした（直接 gh-pages を使うと `fatal: empty ident name (for <runner@fv-az60.xxxxxxxxxxxxxxxxxxxxxxxxxx.cx.internal.cloudapp.net>) not allowed` なんて怒られてしまう。これには workflow 内で自動生成される GITHUB_TOKEN が必要らしいのだけど、便利な action ([peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages))があるので使わせてもらった。）\n\nGitHub Actions のドキュメントは以下を参照した。日本語版だとデッドリンクがあったりURLのフラグメントが設定されてなかったりする。余談だけどドキュメントの規模が大きくなったとき、一部だけ見て理解できるようにコンテキストを少なくして作成できたらいいだろうなと思うものの、もともとボリュームが大きいのでできるだけスリムに書きたいとも思うし、塩梅は難しいな。\n\n- [Events that trigger workflows - GitHub Docs](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#repository_dispatch)\n    - `repository_dispatch` イベントを発生させるとworkflowをキックできるみたい\n- [Repositories - GitHub Docs](https://docs.github.com/en/rest/reference/repos#create-a-repository-dispatch-event)\n    - 上記イベントを発生させる GitHub API\n- [Creating a personal access token - GitHub Docs](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token)\n    - 外部サイトの Webhook に与える認証について\n    - 一年で revoke されるっぽいので、ブログ更新を一年サボると動かなくなる\n    - 今回は repo > public_repo でよい\n    - その乗せ方\n        - [Resources in the REST API - GitHub Docs](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#oauth2-token-sent-in-a-header)\n- [GitHub API v3 | GitHub Developer Guide](https://developer.github.com/v3/#user-agent-required)\n    - GitHub APIは、User-Agent ヘッダがないとエラーになるみたい。なんか適当なのを入れておく\n\n### misc\nそれぞれ触ってみての感想\n\n#### Headless CMS\nなんで Headless CMS にしたか。ローカルにファイル作ってもいいかとも思ったけど、知らないものは触っておくことにした。後付で理由も考えてみたけど…。\n\n- jekyllの場合\n    - ディレクトリやファイル名で記事のURLが決まる。面倒くさい\n    - リポジトリが手元にある必要がある\n- Headless CMSの場合\n    - Webフォームで入力する。そこまで面倒じゃない\n        - 画面開いてログインするのは面倒くさい\n    - ブラウザがあればpublishできるのでポータビリティはある\n    - Headless CMSのほうが記事を書くための心理的障壁が下がるかなと思う。\n\n#### Contentful\n- UIの分かりやすさはある。探してるものがすぐ見つかる\n    - 編集画面はちょっと狭くて好きではない\n    - publishDate、デフォで現在時刻を入れてて欲しい\n- Firefox だとコンソールにエラーがでまくってて、そのせいか vim-vixen が動かず、そこが不満ではある…\n- 他にもさらっと候補を調べてみたけどそこまで時間かけなくていいかと思った程度\n\n#### Gatsby\n- tutorial 分かりやすい。React を触ったことがあればすいすい進む\n- GraphiQL がついてくるので、クエリの結果を確かめるのが簡単\n- plugin をもりもり入れる\n  - gatsby-config.js が太るし、ここに Graphql のクエリを書く場合もあり、リッチなものを作ろうと思ったらつらくなりそう\n- Markdown ファイルと Contentful を併存させようとして遭遇したエラーがちょっと分かりにかった\n  - 結局 Markdown は Contentful に手作業で移行した…\n"},"title":"Gatsby + Contentful on GitHub Pages","slug":"gatsby_contentful_gh_pages","updatedAt":"2020-09-06T00:57:02.100Z"},"next":null}},"staticQueryHashes":["2390137347","3000541721"]}
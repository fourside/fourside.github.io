{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/component_tests",
    "result": {"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"コンポーネントのテストを書きました","publishDate":"2022/04/15 00:45:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"最近書いたコンポーネントのテストで、よかったこと気づいたことをメモしておきます。主に react testing library を使っていて、それが前提になっています。 testing library 用の eslint rule が便利 eslint-plugin-testing-library | Testing…","html":"<p>最近書いたコンポーネントのテストで、よかったこと気づいたことをメモしておきます。主に react testing library を使っていて、それが前提になっています。</p>\n<h3>testing library 用の eslint rule が便利</h3>\n<ul>\n<li><a href=\"https://testing-library.com/docs/ecosystem-eslint-plugin-testing-library/\">eslint-plugin-testing-library | Testing Library</a>\n<ul>\n<li>「ここではgetByXXXを使うな」とか、要素取得メソッドの矯正をしてくれる</li>\n<li><code class=\"language-text\">screen.debug()</code> もエラーにしてくれるので、消し忘れ防止になる</li>\n<li>ただ <code class=\"language-text\">targetElement.firstChild</code> みたいに直接 DOM 取得すると怒られるのは少し不便（その行だけ無効にしてしまってる）</li>\n</ul>\n</li>\n</ul>\n<h3>prop drilling したコールバックのテストがしんどい</h3>\n<ul>\n<li>イベントを発火させて、コンポーネントに渡したコールバックが呼ばれていることを確認するテストを書きたい\n<ul>\n<li>イベントを発火するコンポーネントとテスト対象のコンポーネントが分かれているとき、さらにその二者が遠く離れているとき、イベント発火コンポーネントに至るまでの DOM 構造を知っていなければいけない問題がある\n<ul>\n<li>直接の親子なら親は子に依存してるので、少しくらい知っていてもいいかと思うのだけど、孫やひ孫くらい離れていると知りすぎている感があってつらい</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>コンポーネント毎にユニークなtest-idがあればいいのかもしれない\n<ul>\n<li>それでも DOM 上での登場順に気を配らなくてはいけないけども</li>\n</ul>\n</li>\n</ul>\n<h3>SWR を使うときはキャッシュに気をつける</h3>\n<ul>\n<li>どう考えてもテスト同士が干渉してる事象があった\n<ul>\n<li>テストAで削除のテストをやると、テストBでは削除されたあとの状態になっていた</li>\n</ul>\n</li>\n<li><a href=\"https://swr.vercel.app/ja/docs/advanced/cache#%E3%83%86%E3%82%B9%E3%83%88%E3%82%B1%E3%83%BC%E3%82%B9%E9%96%93%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E3%83%AA%E3%82%BB%E3%83%83%E3%83%88\">Cache – SWR</a>\n<ul>\n<li>回避策はここに書いてあった（読んでたはずだけど、テスト間でキャッシュするなんて思い至らなかった）</li>\n</ul>\n</li>\n</ul>\n<h3>@mswjs/data が便利</h3>\n<ul>\n<li><a href=\"https://github.com/mswjs/data\">mswjs/data</a>\n<ul>\n<li><a href=\"https://zenn.dev/takepepe/articles/msw-data-userflow-testing\">mswjs/data で広がるテスト戦略</a> で知りました</li>\n</ul>\n</li>\n<li>msw 単体で使うと取得系のテストは簡単に書けるようになるが、更新系のテストでは工夫が必要で悩んでいた\n<ul>\n<li>mswjs/data はその辺の面倒臭さをカバーしてくれるのでありがたい</li>\n</ul>\n</li>\n</ul>\n<h3>React DnD テストしやすい</h3>\n<ul>\n<li><a href=\"https://react-dnd.github.io/react-dnd/docs/testing\">React DnD</a> にテストに関する章があるくらいドキュメントがきちんとしている\n<ul>\n<li>ただ <a href=\"https://react-dnd.github.io/react-dnd/docs/backends/test\">test backend</a> を使うのだと勘違いしていて、しばらくハマってしまった\n<ul>\n<li>testing-library は DOM を扱うので、通常使う HTML5 backend でよい</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>userEventにdragイベントやdropイベントは実装されてないので、fireEventで扱うしかなかった\n<ul>\n<li><a href=\"https://github.com/testing-library/user-event/issues/440\">Simulate drag and drop · Issue #440 · testing-library/user-event</a>\n<ul>\n<li>実装する予定もなさそう</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Intersection Observer は jsdom 環境でテストできない</h3>\n<ul>\n<li><a href=\"https://github.com/jsdom/jsdom/issues/2032\">Support for Intersection Observer? · Issue #2032 · jsdom/jsdom</a>\n<ul>\n<li>jsdom で Intersection Observer が実装されていなかった</li>\n<li>ひとまず下記のようなコードで参照エラーになるのを回避して、実際にテストするのは e2e でやるしかないか？ と思ってます</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">intersectionObserverMock</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">observe</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">disconnect</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span>IntersectionObserver <span class=\"token operator\">=</span> jest<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">mockImplementation</span><span class=\"token punctuation\">(</span>intersectionObserverMock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>issueを辿っていくとshopifyがmockを実装していた\n<ul>\n<li><a href=\"https://github.com/Shopify/quilt/blob/main/packages/jest-dom-mocks/src/intersection-observer.ts\">quilt/intersection-observer.ts at main · Shopify/quilt</a></li>\n</ul>\n</li>\n</ul>\n<h2>以上です</h2>"}}}},"pageContext":{"slug":"component_tests","previous":{"body":{"body":"## 問題\n\n下記のようなディレクトリ構成のプロジェクトがあったとします。\n\n```sh\nsrc/components/\n  model/\n    user/\n      user.tsx\n      user.css.ts\n      user.test.tsx\n      user.stories.tsx\n  page/\n    dashboard/\n      dashboard.tsx\n      dashboard.css.ts\n      dashboard.test.tsx\n      dashboard.stories.tsx\n  ui/\n    button/\n      button.tsx\n      button.css.ts\n      button.test.tsx\n      button.stories.tsx\n```\n\nこのプロジェクトでは、例えば `user.css.ts` は `user.tsx` からのみ依存されているとします。JavaScriptには当然ディレクトリ単位での可視性のスコープなんてものはないため、`user.css.ts` は `dashboard.tsx` からも参照できてしまい、他のコンポーネントを参照する場合はエディタの補完候補に目を凝らさないといけません。\n\n## どうするか\n\n[eslint-plugin-import-only-from-index](https://www.npmjs.com/package/eslint-plugin-import-only-from-index) を作りました。\n\neslintrcにはこのように指定します。\n\n```\n\"plugin\": [\"import-only-from-index\"],\n\"rules\": {\n  \"import-only-from-index/import-only-from-index\": [\"error\", [\"src/components\"]]\n}\n```\n\nオプションで指定するディレクトリ（上記例では `src/components`）からexportしたものはlint errorとします。ただし、indexファイルからexportしたものはerrorとしません。つまり指定ディレクトリから外部に公開したいものは、indexファイルからre-exportすることを強制します。\n\nこれは完全な個人用途なのでpublishしなくてもいいかと思ったんですが、自分で使うときにnpm installできるのは便利だし、特に誰も困らないだろうからいいだろうと決めてpublishしました。\n\n## やったこと\n\n- Eslint Pluginの作成\n- TypeScript Server Pluginの作成\n\n### Eslint Plugin\n\n[Working with Plugins - ESLint](https://eslint.org/docs/developer-guide/working-with-plugins) では Yeoman のテンプレートが内されていますが、npx一発では作れないので諦めました。がそれ以外は、plugin作成用のlint ruleの案内があったりしてよかったです。\n\n初手としては、[Quramy/eslint-plugin-tutorial](https://github.com/Quramy/eslint-plugin-tutorial) というチュートリアルが分かりやすかったです。pluginが求めるインターフェイス、簡単なルールの書き方、そのテストのやり方、ASTについて分かりやすく案内されています。\n\nそしてここから先はロジックの話ですが、作ってみて気づいたのが、import文の曖昧なパターンの存在です。`import * from './hoge';` としたとき、二つの解釈が生まれます。\n\n- `hoge` ディレクトリにある `index.ts` からのインポート\n- `hoge` ファイルで、何らかの拡張子が省略されている（`hoge.ts` なのか、`hoge.tsx` なのかは字句のみでは分からない）\n\nそれらしい方法も思いつかないので、愚直にファイルシステムにアクセスして何が存在するのか確かめることにしています。それに伴って、テストでもbeforeAll/afterAllでディレクトリやファイルを作って後始末をしたくなるんですが、eslintのtest runnerにはそれがありません。そこで [Vitest](https://vitest.dev/)でeslint test runnerを囲うことにしました。Vitestは依存ライブラリが少ないし簡単に実行できてよいですね。簡単なテストにはmochaを選びがちだったんですが、これからはVitestでよさそうです。\n\n### TypeScript Server Plugin\n\nEslintのpluginだけではエディタの補完候補までは制御できないので、Language Serverのレスポンスに介入できるTypeScript Server Pluginを作ってみました。コンパイラオプションの `plugins` に指定します。\n\n```\n\"compilerOptions\": {\n  \"plugins\": [\n    {\n      \"name\": \"eslint-plugin-import-only-from-index\",\n      \"restrictedPath\": \"src/components\"\n    }\n  ]\n}\n```\n\n[Writing a Language Service Plugin · microsoft/TypeScript Wiki](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin) が入門にちょうどよかったです。テストに関しては実際にプロジェクトを作って確かめろというスタンスで、どうにかテストできないかなと模索したんですが、そもそもtsserverの型定義がなく諦めました。（[Quramy/typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service/blob/master/e2e/helper/server.ts) を見ると丁寧にやってて、ここまでやる気力はわかなかった…）\nユニットテストできない、かつプリントデバッグできないので、環境変数`TSS_LOG`を使って動作確認していくのがしんどかったです。多少苦労してもtsserverを扱ったほうがよいのかも。\n\nハマりどころとして、VS Codeで使用するTypeScriptをworkspaceのものを指定しなければ動作しないというのがありました。`.vscode/settings.json`に` \"typescript.tsdk\": \"node_modules/typescript/lib\"`と書くやつですね（F1キーで`TypeScript: Select TypeScript Version`する）。\n\n### 参考にさせてもらったリポジトリや記事\n\n- [uhyo/eslint-plugin-import-access](https://github.com/uhyo/eslint-plugin-import-access)\n  - eslint pluginとtypescript server pluginを同じエントリポイントで公開する方法が参考になりました\n- [TSServerの使い方メモ - Qiita](https://qiita.com/Quramy/items/c2835bc380c3e822d479#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%9B%B8%E5%BC%8F)\n\n## おわりに\n\n今回は単純なimport文だったのでASTの深いところまで潜らずに済みましたが、もうちょっと勉強できるお題があったらよかった…。\n"},"title":"Eslint Pluginを作りました","slug":"eslint_plugin","updatedAt":"2022-03-28T13:24:22.442Z"},"next":null}},
    "staticQueryHashes": ["1784162573","882115108"]}
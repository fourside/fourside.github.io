{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/next12_jest_vanilla-extract",
    "result": {"data":{"site":{"siteMetadata":{"title":"fourside.github.io"}},"contentfulBlogPost":{"title":"Next.js 12.1 x jest x vanilla-extract でハマったこと","publishDate":"2022/03/15 00:00:00 +00:00","body":{"childMarkdownRemark":{"excerpt":"TL;DR Next.jsのドキュメントをちゃんと読んで設定を書くこと。 は swc でビルドできるプロジェクト向け 構成 Next.js 12.1 jest React Testing Library vanilla-extract 起きたこと vanilla-extract の styleVariants…","html":"<h2>TL;DR</h2>\n<p>Next.jsのドキュメントをちゃんと読んで設定を書くこと。<code class=\"language-text\">next/jest</code> は swc でビルドできるプロジェクト向け</p>\n<h2>構成</h2>\n<ul>\n<li>Next.js 12.1</li>\n<li>jest</li>\n<li>React Testing Library</li>\n<li>vanilla-extract</li>\n</ul>\n<h2>起きたこと</h2>\n<p>vanilla-extract の <a href=\"https://vanilla-extract.style/documentation/styling-api/#stylevariants\">styleVariants</a> を使ったコンポーネントのテストが、以下のようなエラーを吐いて失敗する。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">TypeError: Cannot read properties of undefined (reading 'primary')</code></pre></div>\n<h2>調べたこと</h2>\n<ul>\n<li>React Testing Library の <code class=\"language-text\">screen.debug</code> 関数を呼び出してみると、vanilla-extract が出力するはずのクラス名が undefined になっている</li>\n<li>console.log を仕込んだ結果、どうやら jest から <code class=\"language-text\">@vanilla-extract/babel-plugin</code> が呼ばれていない\n<ul>\n<li>こいつは <code class=\"language-text\">*.css.ts</code> ファイルを読み込んでクラス名を生成したりする babel plugin</li>\n</ul>\n</li>\n<li><code class=\"language-text\">jest --verbose</code> で jest の実行時の設定を確認してみる\n<ul>\n<li><code class=\"language-text\">jest --verbose hoge</code> のように存在しないテストケース名を与えるとテストが実施されずに早い</li>\n</ul>\n</li>\n<li>ただの好奇心から Next.js 12.1 から導入された <a href=\"https://nextjs.org/docs/testing#setting-up-jest-with-the-rust-compiler\">next/jest</a> を使っていたので、いろいろ設定が追加されている</li>\n<li>transform にも予め設定があり、自分で用意した transform の設定がその後に追加されていた\n<ul>\n<li>それもそのはず、jest.config.js では最後に <code class=\"language-text\">next/jest</code> から生成した関数で設定をwrapしてるのでそうなる</li>\n</ul>\n</li>\n<li>おそらく同一ファイルに transform は二重にかからず、自分の設定が無視されていて、結果 vanilla-extract の babel plugin が呼ばれない雰囲気が漂う\n<ul>\n<li>改めて調べると <a href=\"https://jestjs.io/ja/docs/next/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object\">Jestの設定 - transform</a> に <code class=\"language-text\">A transformer is only run once per file unless the file has changed. </code> とある</li>\n</ul>\n</li>\n<li>そこで試しに <code class=\"language-text\">next/jest</code> をやめたら、あっさりスタイルは生成されるようになった</li>\n<li>さらに Next.js のドキュメントをよく読むと、 <a href=\"https://nextjs.org/docs/testing#setting-up-jest-with-babel\">Setting up Jest (with Babel)</a> があり、<code class=\"language-text\">next/jest</code> を使わないならマニュアルで設定を書けとある。ドキュメントをちゃんと読もう！</li>\n</ul>\n<blockquote>\n<p>If you opt-out of the Rust Compiler, you will need to manually configure Jest and install babel-jest and identity-obj-proxy in addition to the packages above.</p>\n</blockquote>\n<p>とあるものの、<code class=\"language-text\">babel-jest</code> は jest インストール時に同梱されてくるので、改めてインストールする必要はなさそう。</p>\n<p>最終的な <code class=\"language-text\">jest.config.js</code> はこれで十分でした。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/** @type {import('@jest/types').Config.InitialOptions} */</span>\n<span class=\"token keyword\">const</span> customJestConfig <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">setupFilesAfterEnv</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;rootDir>/jest.setup.js\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">transform</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string-property property\">\"\\\\.js$\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"babel-jest\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"\\\\.tsx?$\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"babel-jest\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">configFile</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./.babelrc\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">testEnvironment</span><span class=\"token operator\">:</span> <span class=\"token string\">\"jest-environment-jsdom\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> customJestConfig<span class=\"token punctuation\">;</span></code></pre></div>\n<p>（js に対する transform 設定は、単に babel.setup.js で import 文を書き直したくなかっただけのためのもの）</p>\n<h2>おわりに</h2>\n<p>ビジュアルレグレッションテストをするわけではない場合には、本来スタイル生成はテストに不要なはずなので、テストを速くするにはテスト実行時に影響する <code class=\"language-text\">styleVariants</code> API を避けないといけないのか…という悩みがうまれました。</p>"}}}},"pageContext":{"slug":"next12_jest_vanilla-extract","previous":{"body":{"body":"## 何を作ったか\n\n[Spotifyのプレイリスト編集アプリ](https://spotify-playlist-editor.fourside.dev/) です。リポジトリは[これ](https://github.com/fourside/spotify_playlist_editor)です。\n\nSpotifyのDiscover weeklyを聞きつつ（Spotifyがrecommendしてくれる週替りのプレイリストです）、気になった曲をお気に入りに追加して聞き直すという楽しみ方を2年間くらい続けているのですが、それが現在600曲以上になり、特別困ってはいないものの、何らかの基準で別なプレイリストに逃したいな…と思って作りました。\n\n![playlist editor operation gif](//images.ctfassets.net/2zg7j2cy03uu/6PP5HpysXh0zCH5Au4lLQG/3c5d6a94cd51654b82419f94e56259fe/playlist_editor.gif)\n\nで、こういうときは使ってみたいライブラリを触っていくのも楽しみのひとつで、それぞれ使ってみた感想を書き残します。\n\n## 使ってみたライブラリ\n\nベースはNext.jsです。\n\n- NextAuth.js\n- vanilla-extract\n- React DnD\n- SWR\n- Radix UI\n- Storybook\n- React Testing Library\n- msw\n\n### NextAuth.js\n- [NextAuth.js](https://next-auth.js.org/)\n- 特定プロバイダのOAuth処理をNext.jsに簡単に導入してくれるやつ\n  - プロバイダの数が充実していて、Spotifyもサポートされていた\n    - 正直、プロバイダがひとつくらいなら自前実装でもよいかも\n    - 複数サポートしたいときにメリットを感じられる気がします\n  - (vercelにjoinしてる方が作ってるので安心感はある)\n- 戸惑ったところ\n  - どうやってスコープを渡すのか\n    - ProviderにクライアントIDなど渡す関数にAuthorization URLを生成するところがあり、そこにパラメータとして渡せる\n      - 今となってはドキュメントから参照されてるコードをちゃんと読めば分かったかも\n  - Spotify APIが要求するAccessTokenはどう取れるのか\n    - [Getting Started | NextAuth.js](https://next-auth.js.org/getting-started/example#extensibility)\n      - access tokenは、jwtコールバックに渡されるaccountオブジェクトに、認証完了後にだけ入ってるので、それをtokenオブジェクトに詰め、それが次のsessionコールバックに渡されるのでそこでも詰め直しをする、というたらい回しをした\n      - このまどろっこしさ、これで正しいの？ という疑念はある…\n\n### vanilla-extract\n- [vanilla-extract](https://vanilla-extract.style/)\n- ゼロランタイムのCSSライブラリで、[The State of CSS 2021](https://2021.stateofcss.com/en-US/technologies/css-in-js) で名前を見かけて試しに使ってみようかという感じ\n- CSS ModuleのTypeScript版という感じ\n  - className単位でexportすることになるので、エディタの補完候補がはちゃめちゃに多くなるのが気にならなければ…\n- jest実行時には多分設定が必要で、特に何もしなければCSSは生成されない\n  - この [styleVariants](https://vanilla-extract.style/documentation/styling-api/#stylevariants) がjest実行時にundefinedになってしまい、テストケース内でrenderさせるとエラーが起きてしまう\n  - 結局、回避する手段が分からず、styleVariantsをやめてしまった :cry:\n- スタイルの合成は、通常使う `style` 関数でできる\n    - CSSのオブジェクトも受け取れるし、その配列も受け取れるようになっている。便利。\n- (改めてオフィシャルサイト見てみたら、ジョンレシグ先生のtweetが紹介されてる)\n\n### React DnD\n- [React DnD](https://react-dnd.github.io/react-dnd/about)\n- ReactでDrag and Dropを簡単に扱えるやつ\n- 職場で触る機会があったし、シンプルに使えるので、これを採用した\n  - [react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd) もデモがきれいだったしAtlassianが作ってるのかーと好印象だったんだけど、開発を止めてるそうなので見送った\n  - Dragが終わったイベント検知を、Dragが発生した側でハンドルできるのがよい\n    - Dropイベント側で曲の追加をして、Dragイベント側で曲の削除をする\n\n### SWR\n- [データ取得のための React Hooks ライブラリ – SWR](https://swr.vercel.app/ja)\n- fetchのresponseをReactのstateとして扱うやつ\n- 便利なんだけど、以下ちょっとだけ不満点がふたつ\n- useSWRに与える第2引数のfetcherが、第1引数のkeyを受け取ることになっていて不便\n  - キーがそのままリクエスト先のURLパスなら便利なんだけど、fetcherの中でzodでJSONのスキーマチェックなど、URLパス毎に個別の処理を入れたいので、URLパスを受け取れる共通化されたfetcherは作りにくい\n\n```typescript\nconst { data, error } = useSWRImmutable(`playlists/${playlistId}`, () => getPlaylistTracks(playlistId));\n```\n\n- useSWRがloadingを返してくれなくて不便\n  - オフィシャルドキュメントでは、errorとdata(レスポンス)がundefinedなら読み取り中という扱いにしている\n  - ページングをするとき、`useSWR` ではなく `useSWRInfinite` というAPIを使うんだけど、その場合 loading をどう表現したらいいのか？という迷いがあり、結果こうなった\n\n```typescript\nconst { data, error, size, setSize } = useSWRInfinite(getKey, fetcher);\nconst loadingNext = size > 0 && data !== undefined && data.length > 0 && data[size - 1] === undefined;\n```\n  - 「sizeは増えてるけど、data[size]番目のデータはまだ取得されていない」すなわち次ページのloading中ということ\n  - swrで持つ状態が増えるとそこでひとつ最適化をしないといけないはずだから、なるべくシンプルに保つためにloadingを持たない選択をしているのかなという理解をした\n\n### Radix UI\n- [Radix UI](https://www.radix-ui.com/docs/primitives/overview/introduction)\n- まだメジャーバージョンが0なheadless componentライブラリ\n  - focus管理とかキーボード操作とか、見た目以外のアクセシビリティを提供してくれるやつ\n  - GitHub Trendingでもよく見かける\n- Dialog(いわゆるモーダル)などを触ってみたけど、ちょいクセを感じた\n  - Triggerというコンポーネント（こいつはDialogを開閉するボタン）を含めないと、ESCキーでDialogを閉じれなかったりする\n- Scroll AreaのスクロールバーがDOMで実装されていてこれが欲しかったんだけど、heightが固定じゃないとスクロールバーが出てくれなくて悲しかった（何故かは追ってない）\n\n### Storybook\n- [Storybook](https://storybook.js.org/)\n- 厳密には仕事で少し触ったことはあるけど、きちんと使いこなせてはいなかった\n- なにより連れてくるnpmモジュールの多さにちょっと引き気味だったのと、連れてくるやつのせいでnpm auditが消えないがちなので、ちょっと及び腰だった\n- 使ってみるとシンプルな記述で、カタログ的にコンポーネントの見た目が確認できるのはすごくうれしい\n- コンポーネントの機能だけ先に作ってから、storybookを用意して、コンポーネントが持つパターン毎にスタイルを当てる、という流れで作業できた\n  - ローディングとかエラー状態とか動作確認しにくいコンポーネントが確認できるのはうれしい\n  - (余談ですが、仕事では一部 [React Cosmos](https://reactcosmos.org/) という軽量なやつを使っていて、これはこれでシンプルでよいです)\n- Storybookが用意しているドキュメントがしっかりしていて分かりやすいというのもよい\n\n### React Testing Library\n- [React Testing Library | Testing Library](https://testing-library.com/docs/react-testing-library/intro/)\n- Reactのコンポーネント自体をテストしたことがあまりなく、これも及び腰だったので試してみたけど、これもよかった\n  - Reactの内部ではなく、実際にユーザーが体験することに対して関心があるテストが書けるようになっている\n  - enzymeの置き換えになるというのがセールスポイントとしていたんだけど、かなり昔にちょろっと触った程度なので面倒臭さは忘れてしまった…\n    - 確かにセットアップは簡単だった\n- 表示のテストはStorybookでやる（手作業になるけど）一方で動作の確認はReact Testing Libraryでカバーという棲み分けも分かりやすくてよい\n- 単項目のシンプルなフォームに対して書いたテストケースは20個くらい書いた\n  - なるべくアサーションルーレットにならないように気をつけた結果の数なんだけど、思ったより少ないか\n  - 必須項目のエラーをいつ出すかとか、ラベルをクリックしてフォーカスが移るかとか、enterでもボタンクリックでもsubmitできるかとか、挙動をテストしたい項目はそれなりにあって、これがテストで書けるのはかなり安心感を得られてよい\n    - 実際テストが通らず、バグが直せたのも体験よかった\n\n### MSW\n- [MSW](https://mswjs.io/)\n- http通信をinterruptしてモックデータを返すやつ\n- このアプリがほぼ出来上がってから使い始めたので、全エンドポイントにモックデータを用意するのがダルくて、ちゃんとやれてない\n  - mswで定義してないエンドポイントに対してリクエストがあったとき、サーバコンソールにログが出てしまったり、socketが中途半端な状態になるのかエラーになったりしがちだった\n  - Intersection ObserverでInfinite loadingを実装するとき、リクエストが多数発生してSpotifyから429が返ってきてしまったことがあり、そのときモックデータが役に立ちました\n- Storybookやユニットテストで使えたら便利そう(まだ使えていない)\n\n## その他やったこと\n- ディレクトリの切り方は [SPA Componentの推しディレクトリ構成について語る](https://zenn.dev/yoshiko/articles/99f8047555f700) を参考にしました\n- 主に、components以下を model と ui に分けるやり方\n  - 最初は model と ui に分けなくても十分秩序あるように感じれたのだけど、Radix UI を使い始めてから ui のあり方だけに関心を持つコンポーネントが生まれ始め、分けるタイミングを感じた\n  - そしてtestやstorybook、cssも別ファイルで分かれるので、コンポーネントにべったりなhooksも外に出したりした\n\n## やらなかったこと\n- hooksのテスト\n  - それ用のライブラリである [React Hooks Testing Library](https://react-hooks-testing-library.com/) を見つけて、よしと思ったんだけど、`Your hook is defined alongside a component and is only used there` とあり、コンポーネント本体のテストでカバーすべきかと思い直したので\n\n## 難しかったこと\n- lighthouseを実行し、html形式のレポートをgh-pagesにデプロイする\n  - Spotifyの認証画面から先がpuppeteerが不安定、だいたいいつもタイムオーバーになる\n  - そのせいでログイン試行がかさみ、Spotifyから疑わしい行動があったとしてパスワードリセットされてしまった\n  - 無事htmlがデプロイされたとしても、githubのリポジトリが検出するlanguageがhtmlになってしまって若干悲しい\n- またlighthouseは型定義をきちんとした形で提供してくれておらず、definitely typedも存在しないので、どうにか誤魔化すしかなく、そこも面倒くさいポイントではあった\n\n# 終わりに\n以上です(これも余談ですが、一旦人に見せると満足してしまって開発意欲が減ってしまいますね、見せないで悶々と作って行くほうがいいのか？)\n"},"title":"Spotifyのプレイリストエディタを作りました","slug":"spotify_playlist_editor","updatedAt":"2022-03-15T00:12:53.718Z"},"next":{"body":{"body":"## 問題\n\n下記のようなディレクトリ構成のプロジェクトがあったとします。\n\n```sh\nsrc/components/\n  model/\n    user/\n      user.tsx\n      user.css.ts\n      user.test.tsx\n      user.stories.tsx\n  page/\n    dashboard/\n      dashboard.tsx\n      dashboard.css.ts\n      dashboard.test.tsx\n      dashboard.stories.tsx\n  ui/\n    button/\n      button.tsx\n      button.css.ts\n      button.test.tsx\n      button.stories.tsx\n```\n\nこのプロジェクトでは、例えば `user.css.ts` は `user.tsx` からのみ依存されているとします。JavaScriptには当然ディレクトリ単位での可視性のスコープなんてものはないため、`user.css.ts` は `dashboard.tsx` からも参照できてしまい、他のコンポーネントを参照する場合はエディタの補完候補に目を凝らさないといけません。\n\n## どうするか\n\n[eslint-plugin-import-only-from-index](https://www.npmjs.com/package/eslint-plugin-import-only-from-index) を作りました。\n\neslintrcにはこのように指定します。\n\n```\n\"plugin\": [\"import-only-from-index\"],\n\"rules\": {\n  \"import-only-from-index/import-only-from-index\": [\"error\", [\"src/components\"]]\n}\n```\n\nオプションで指定するディレクトリ（上記例では `src/components`）からexportしたものはlint errorとします。ただし、indexファイルからexportしたものはerrorとしません。つまり指定ディレクトリから外部に公開したいものは、indexファイルからre-exportすることを強制します。\n\nこれは完全な個人用途なのでpublishしなくてもいいかと思ったんですが、自分で使うときにnpm installできるのは便利だし、特に誰も困らないだろうからいいだろうと決めてpublishしました。\n\n## やったこと\n\n- Eslint Pluginの作成\n- TypeScript Server Pluginの作成\n\n### Eslint Plugin\n\n[Working with Plugins - ESLint](https://eslint.org/docs/developer-guide/working-with-plugins) では Yeoman のテンプレートが内されていますが、npx一発では作れないので諦めました。がそれ以外は、plugin作成用のlint ruleの案内があったりしてよかったです。\n\n初手としては、[Quramy/eslint-plugin-tutorial](https://github.com/Quramy/eslint-plugin-tutorial) というチュートリアルが分かりやすかったです。pluginが求めるインターフェイス、簡単なルールの書き方、そのテストのやり方、ASTについて分かりやすく案内されています。\n\nそして、作ってみて気づいたのが、import文の曖昧なパターンの存在です。`import * from './hoge';` としたとき、二つの解釈が生まれます。\n\n- `hoge` ディレクトリにある `index.ts` からのインポート\n- `hoge` ファイルで、何らかの拡張子が省略されている（`hoge.ts` なのか、`hoge.tsx` なのかは字句のみでは分からない）\n\nそれらしい方法も思いつかないので、愚直にファイルシステムにアクセスして何が存在するのか確かめることにしています。それに伴って、テストでもbeforeAll/afterAllでディレクトリやファイルを作って後始末をしたくなるんですが、eslintのtest runnerにはそれがありません。そこで [Vitest](https://vitest.dev/)でeslint test runnerを囲うことにしました。Vitestは依存ライブラリが少ないし簡単に実行できてよいですね。簡単なテストにはmochaを選びがちだったんですが、これからはVitestでよさそうです。\n\n### TypeScript Server Plugin\n\nEslintのpluginだけではエディタの補完候補までは制御できないので、Language Serverのレスポンスに介入できるTypeScript Server Pluginを作ってみました。コンパイラオプションの `plugins` に指定します。\n\n[Writing a Language Service Plugin · microsoft/TypeScript Wiki](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin) が入門にちょうどよかったです。テストに関しては実際にプロジェクトを作って確かめろというスタンスで、どうにかテストできないかなと模索したんですが、そもそもtsserverの型定義がなく諦めました。（[Quramy/typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service/blob/master/e2e/helper/server.ts) を見ると丁寧にやってて、ここまでやる気力はわかなかった…）\nユニットテストできない、かつプリントデバッグできないので、環境変数`TSS_LOG`を使って動作確認していくのがしんどかったです。多少苦労してもtsserverを扱ったほうがよいのかも。\n\nハマりどころとして、VS Codeで使用するTypeScriptをworkspaceのものを指定しなければ動作しないというのがありました。`.vscode/settings.json`に` \"typescript.tsdk\": \"node_modules/typescript/lib\"`と書くやつですね（F1キーで`TypeScript: Select TypeScript Version`する）。\n\n### 参考にさせてもらったリポジトリや記事\n\n- [uhyo/eslint-plugin-import-access](https://github.com/uhyo/eslint-plugin-import-access)\n  - eslint pluginとtypescript server pluginを同じエントリポイントで公開する方法が参考になりました\n- [TSServerの使い方メモ - Qiita](https://qiita.com/Quramy/items/c2835bc380c3e822d479#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%9B%B8%E5%BC%8F)\n\n## おわりに\n\n今回は単純なimport文だったのでASTの深いところまで潜らずに済みましたが、もうちょっと勉強できるお題があったらよかった…。\n"},"title":"Eslint Pluginを作りました","slug":"eslint_plugin","updatedAt":"2022-03-28T13:18:21.583Z"}}},
    "staticQueryHashes": ["1784162573","882115108"]}